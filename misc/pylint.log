************* Module boinor.frames.ecliptic
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.constants.__init__:[103:171]
==boinor.constants.general:[42:110]
__all__ = [
    "J2000",
    "J2000_TDB",
    "J2000_TT",
    "GM_sun",
    "GM_earth",
    "GM_mercury",
    "GM_venus",
    "GM_mars",
    "GM_jupiter",
    "GM_saturn",
    "GM_uranus",
    "GM_neptune",
    "GM_pluto",
    "GM_moon",
    "GM_phobos",
    "GM_deimos",
    "GM_europa",
    "GM_ganymede",
    "GM_enceladus",
    "GM_titan",
    "GM_titania",
    "GM_triton",
    "GM_charon",
    "M_earth",
    "M_jupiter",
    "M_sun",
    "R_mean_earth",
    "R_mean_mercury",
    "R_mean_venus",
    "R_mean_mars",
    "R_mean_jupiter",
    "R_mean_saturn",
    "R_mean_uranus",
    "R_mean_neptune",
    "R_mean_pluto",
    "R_mean_moon",
    "R_earth",
    "R_mercury",
    "R_venus",
    "R_mars",
    "R_jupiter",
    "R_saturn",
    "R_sun",
    "R_uranus",
    "R_neptune",
    "R_pluto",
    "R_moon",
    "R_polar_earth",
    "R_polar_mercury",
    "R_polar_venus",
    "R_polar_mars",
    "R_polar_jupiter",
    "R_polar_saturn",
    "R_polar_uranus",
    "R_polar_neptune",
    "R_polar_pluto",
    "R_polar_moon",
    "J2_sun",
    "J2_earth",
    "J3_earth",
    "J2_mars",
    "J3_mars",
    "J2_venus",
    "J3_venus",
    "H0_earth",
    "rho0_earth",
    "Wdivc_sun", (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.constants.__init__:[182:201]
==boinor.constants.mean_elements:[29:49]
    "mean_a_mercury",
    "mean_a_venus",
    "mean_a_earth",
    "mean_a_mars",
    "mean_a_jupiter",
    "mean_a_saturn",
    "mean_a_uranus",
    "mean_a_neptune",
    "mean_a_moon",
    "mean_a_phobos",
    "mean_a_deimos",
    "mean_a_europa",
    "mean_a_ganymede",
    "mean_a_enceladus",
    "mean_a_titan",
    "mean_a_titania",
    "mean_a_triton",
    "mean_a_charon",
]
 (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.core.propagation.danby:[9:23]
==boinor.core.propagation.recseries:[23:47]
    semi_axis_a = p / (1 - ecc**2)
    # mean angular motion
    n = np.sqrt(k / np.abs(semi_axis_a) ** 3)

    if ecc == 0:
        # Solving for circular orbit

        # compute initial mean anoamly
        M0 = nu  # For circular orbit (M = E = nu)
        # final mean anaomaly
        M = M0 + n * tof
        # snapping anomaly to [0,pi] range
        nu = M - 2 * np.pi * np.floor(M / 2 / np.pi)

        return nu

    elif ecc < 1.0:
        # Solving for elliptical orbit

        # compute initial mean anoamly
        M0 = E_to_M(nu_to_E(nu, ecc), ecc)
        # final mean anaomaly
        M = M0 + n * tof
        # snapping anomaly to [0,pi] range (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.twobody.propagation.danby:[30:41]
==boinor.twobody.propagation.mikkola:[30:41]
                state.attractor.k.to_value(u.km**3 / u.s**2),
                *state.to_value(),
                tof.to_value(u.s),
            )
            << u.rad
        )

        new_state = ClassicalState(
            state.attractor, state.to_tuple()[:5] + (nu,), state.plane
        )
        return new_state (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.twobody.propagation.farnocchia:[39:52]
==boinor.twobody.propagation.pimienta:[33:44]
                state.attractor.k.to_value(u.km**3 / u.s**2),
                *state.to_value(),
                tof.to_value(u.s),
            )
            << u.rad
        )

        new_state = ClassicalState(
            state.attractor, state.to_tuple()[:5] + (nu,), state.plane
        )
        return new_state

    def propagate_many(self, state, tofs): (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.twobody.propagation.gooding:[35:46]
==boinor.twobody.propagation.markley:[31:42]
                state.attractor.k.to_value(u.km**3 / u.s**2),
                *state.to_value(),
                tof.to_value(u.s),
            )
            << u.rad
        )

        new_state = ClassicalState(
            state.attractor, state.to_tuple()[:5] + (nu,), state.plane
        )
        return new_state (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.io:[63:70]
==boinor.twobody.orbit.creation:[500:507]
        a=a,
        ecc=ecc,
        inc=inc,
        raan=raan,
        argp=argp,
        nu=nu,
        epoch=epoch.tdb, (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.earth.atmosphere.coesa62:[215:260]
==boinor.earth.atmosphere.coesa76:[268:313]
        return rho.to(u.kg / u.m**3)

    def properties(self, alt, geometric=True):
        """Solves temperature, pressure, density at given height.

        Parameters
        ----------
        alt : ~astropy.units.Quantity
            Geometric/Geopotential height.
        geometric : bool
            If `True`, assumes that `alt` argument is geometric kind.

        Returns
        -------
        T: ~astropy.units.Quantity
            Temperature at given height.
        p: ~astropy.units.Quantity
            Pressure at given height.
        rho: ~astropy.units.Quantity
            Density at given height.
        """
        T = self.temperature(alt, geometric=geometric)
        p = self.pressure(alt, geometric=geometric)
        rho = self.density(alt, geometric=geometric)

        return T, p, rho

    def sound_speed(self, alt, geometric=True):
        """Solves speed of sound at given height.

        Parameters
        ----------
        alt : ~astropy.units.Quantity
            Geometric/Geopotential height.
        geometric : bool
            If `True`, assumes that `alt` argument is geometric kind.

        Returns
        -------
        Cs: ~astropy.units.Quantity
            Speed of Sound at given height.
        """
        # Check if valid range and convert to geopotential
        z, h = self._check_altitude(alt, r0, geometric=geometric)
 (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.iod.izzo:[5:48]
==boinor.iod.vallado:[5:59]
kms = u.km / u.s


def lambert(
    k, r0, r, tof, M=0, prograde=True, lowpath=True, numiter=35, rtol=1e-8
):
    """Solves the Lambert problem.

    .. versionadded:: 0.3.0

    Parameters
    ----------
    k : ~astropy.units.Quantity
        Gravitational constant of main attractor (km^3 / s^2).
    r0 : ~astropy.units.Quantity
        Initial position (km).
    r : ~astropy.units.Quantity
        Final position (km).
    tof : ~astropy.units.Quantity
        Time of flight (s).
    M : int, optional
        Number of full revolutions, default to 0.
    prograde: boolean
        Controls the desired inclination of the transfer orbit.
    lowpath: boolean
        If `True` or `False`, gets the transfer orbit whose vacant focus is
        below or above the chord line, respectively.
    numiter : int, optional
        Maximum number of iterations, default to 35.
    rtol : float, optional
        Relative tolerance of the algorithm, default to 1e-8.

    Returns
    -------
    v0, v : tuple
        Pair of velocity solutions.

    Raises
    ------
    RuntimeError
        If it was not possible to compute the orbit.

    Notes
    -----
    This uses the universal variable approach found in Battin, Mueller & White
    with the bisection iteration suggested by Vallado. Multiple revolutions
    not supported.

    """
    k_ = k.to_value(u.km**3 / u.s**2)
    r0_ = r0.to_value(u.km)
    r_ = r.to_value(u.km)
    tof_ = tof.to_value(u.s)
 (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.io:[64:69]
==boinor.twobody.orbit.creation:[422:427]
        ecc=ecc,
        inc=inc,
        raan=raan,
        argp=argp,
        nu=nu, (duplicate-code)
src/boinor/frames/ecliptic.py:1:0: R0801: Similar lines in 2 files
==boinor.io:[63:68]
==boinor.twobody.orbit.creation:[308:313]
            a=a,
            ecc=ecc,
            inc=inc,
            raan=raan,
            argp=argp, (duplicate-code)

------------------------------------------------------------------
Your code has been rated at 9.98/10 (previous run: 9.97/10, +0.00)

